START
-----

start a web UI:
cd cmd/workwebui
go run main.go
open "http://localhost:5040/worker_pools"
open "http://localhost:5040/busy_workers"
open "http://localhost:5040/jobs"

Enqueue some foobar jobs:
cd cmd/workfakedata
go run main.go

TODO
----
 - Make sure all TODOs in code are addressed.
 - rescue panics; test
 - Make sure comments are good and all godoc produces good results
 - add some more tests for runJob that test errors
 - dont removing from :inprogress if queue onto dead/retry fails
 - Enqueue should cache job names. If it's a new job name, sadd it
 - checkin stuff -- what's the status on that now?
 - make start, stop, start work, & make start idempotent (on the pool)
 - validation on job options, set defaults if relevant.
 - Error message on the context stuff
 - README stuff:
   - context
   - checkin
   - scheduled jobs
 - Benchmark latest version of goworker and go-workers again
 - implement DeleteAllDeadJobs and RetryAllDeadJobs; test; wire up to the webui.
 - unified signal handling
 
 - benchmarks for runJob
 - investigate changing runJob to use a shared context, and zero'ing it's value each time
 - write better tests for Enqueue and EnqueueIn
 - revisit the retry backoff
 - generally, look into process scalability. Eg, if we have 30 processes, each with concurrency=25, that's a lot of pinging redis
 - thought: what if we *scale up* to max workers if some are idle, should we shut them down?
   - thing we're guarding against: 100 goroutines all polling redis
   - alt: some clever mechanism to only check redis if we are busy?
 - is there some way to detect redis contention, or overall, just measure the latency of redis
   - both lock contention (not enuf redis pool)
   - enuf pool, but redis itself is overloaded
 - It could be cool to provide an API for that redis stuff.
   - latencies
   - lock contention
   - number of redis connections used by work
   - overall redis stuff: mem, avail, cxns
 - it might be nice to have an overall counter like sidekiq
